from decimal import Decimal

from django.test import TestCase
from django.contrib.auth import get_user_model

from apps.contacts.models import Contact, Business
from apps.jobs.models import (
    Job, EstWorksheet, Task, TaskMapping, TaskTemplate, 
    WorkOrderTemplate, ProductBundlingRule, Estimate, EstimateLineItem
)
from apps.jobs.services import EstimateGenerationService


User = get_user_model()


class EstimateGenerationServiceTestCase(TestCase):
    """Comprehensive tests for EstimateGenerationService"""
    
    def setUp(self):
        """Set up test data"""
        # Create a test user
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )
        
        # Create a test business and contact
        self.business = Business.objects.create(
            business_name='Test Company',
            business_address='123 Test St'
        )
        
        self.contact = Contact.objects.create(
            name='Test Customer',
            email='customer@example.com',
            business=self.business
        )
        
        # Create a test job
        self.job = Job.objects.create(
            job_number='TEST-001',
            contact=self.contact,
            description='Test Job for Estimate Generation'
        )
        
        # Create a test worksheet
        self.worksheet = EstWorksheet.objects.create(
            job=self.job,
            status='draft'
        )
        
        # Initialize the service
        self.service = EstimateGenerationService()
    
    def test_direct_mapping_single_task(self):
        """Test converting a single task with direct mapping to a line item"""
        # Create a task with direct mapping
        task = Task.objects.create(
            est_worksheet=self.worksheet,
            name='Design Services',
            units='hours',
            rate=Decimal('150.00'),
            est_qty=Decimal('8.00')
        )
        
        TaskMapping.objects.create(
            task=task,
            step_type='labor',
            mapping_strategy='direct',
            task_type_id='design',
            line_item_description='Custom design services for project'
        )
        
        # Generate estimate
        estimate = self.service.generate_estimate_from_worksheet(self.worksheet)
        
        # Verify estimate was created
        self.assertIsNotNone(estimate)
        self.assertEqual(estimate.job, self.job)
        self.assertEqual(estimate.status, 'draft')
        
        # Verify line item was created
        line_items = estimate.estimatelineitem_set.all()
        self.assertEqual(line_items.count(), 1)
        
        line_item = line_items.first()
        self.assertEqual(line_item.description, 'Custom design services for project')
        self.assertEqual(line_item.qty, Decimal('8.00'))
        self.assertEqual(line_item.units, 'hours')
        self.assertEqual(line_item.price_currency, Decimal('1200.00'))  # 8 * 150
        self.assertEqual(line_item.task, task)
    
    def test_direct_mapping_multiple_tasks(self):
        """Test converting multiple tasks with direct mapping"""
        # Create multiple tasks with direct mapping
        tasks_data = [
            ('Design', 'hours', '150.00', '8.00'),
            ('Consultation', 'hours', '125.00', '4.00'),
            ('Documentation', 'hours', '100.00', '6.00'),
        ]
        
        for name, units, rate, qty in tasks_data:
            task = Task.objects.create(
                est_worksheet=self.worksheet,
                name=name,
                units=units,
                rate=Decimal(rate),
                est_qty=Decimal(qty)
            )
            
            TaskMapping.objects.create(
                task=task,
                step_type='labor',
                mapping_strategy='direct',
                task_type_id=name.lower()
            )
        
        # Generate estimate
        estimate = self.service.generate_estimate_from_worksheet(self.worksheet)
        
        # Verify all line items were created
        line_items = estimate.estimatelineitem_set.all()
        self.assertEqual(line_items.count(), 3)
        
        # Verify total price
        total = sum(item.price_currency for item in line_items)
        expected_total = Decimal('1200.00') + Decimal('500.00') + Decimal('600.00')
        self.assertEqual(total, expected_total)
    
    def test_product_bundle_single_product(self):
        """Test bundling tasks into a single product line item"""
        # Create a work order template for a table
        table_template = WorkOrderTemplate.objects.create(
            template_name='Custom Table',
            template_type='product',
            product_type='table',
            base_price=Decimal('5000.00')
        )
        
        # Create tasks for the table
        tasks_data = [
            ('CAD Design', 'labor', 'hours', '150.00', '4.00'),
            ('Wood Materials', 'material', 'board_feet', '25.00', '50.00'),
            ('Cut and Shape', 'labor', 'hours', '100.00', '6.00'),
            ('Assembly', 'labor', 'hours', '100.00', '4.00'),
            ('Finishing', 'labor', 'hours', '125.00', '3.00'),
        ]
        
        product_id = 'table_001'
        
        for name, step_type, units, rate, qty in tasks_data:
            task = Task.objects.create(
                est_worksheet=self.worksheet,
                name=name,
                units=units,
                rate=Decimal(rate),
                est_qty=Decimal(qty)
            )
            
            TaskMapping.objects.create(
                task=task,
                step_type=step_type,
                mapping_strategy='bundle_to_product',
                product_identifier=product_id,
                product_type='table',
                task_type_id=name.lower().replace(' ', '_')
            )
        
        # Create bundling rule
        rule = ProductBundlingRule.objects.create(
            rule_name='Table Bundling',
            product_type='table',
            work_order_template=table_template,
            line_item_template='Custom Dining Table',
            combine_instances=False,
            pricing_method='sum_components',
            include_materials=True,
            include_labor=True
        )
        
        # Generate estimate
        estimate = self.service.generate_estimate_from_worksheet(self.worksheet)
        
        # Verify single line item was created
        line_items = estimate.estimatelineitem_set.all()
        self.assertEqual(line_items.count(), 1)
        
        line_item = line_items.first()
        self.assertEqual(line_item.description, 'Custom Dining Table')
        self.assertEqual(line_item.qty, Decimal('1.00'))
        self.assertEqual(line_item.units, 'each')
        
        # Calculate expected price: (4*150) + (50*25) + (6*100) + (4*100) + (3*125)
        expected_price = Decimal('600.00') + Decimal('1250.00') + Decimal('600.00') + Decimal('400.00') + Decimal('375.00')
        self.assertEqual(line_item.price_currency, expected_price)
    
    def test_product_bundle_multiple_instances_combined(self):
        """Test bundling multiple instances of the same product into a single line item"""
        # Create bundling rule that combines instances
        rule = ProductBundlingRule.objects.create(
            rule_name='Chair Bundling',
            product_type='chair',
            line_item_template='Dining Chair Set',
            combine_instances=True,  # Combine into single line
            pricing_method='sum_components'
        )
        
        # Create 4 chairs
        for i in range(1, 5):
            product_id = f'chair_{i:03d}'
            
            tasks_data = [
                ('Chair Frame', 'labor', 'hours', '75.00', '2.00'),
                ('Chair Materials', 'material', 'each', '100.00', '1.00'),
                ('Chair Assembly', 'labor', 'hours', '50.00', '1.50'),
            ]
            
            for name, step_type, units, rate, qty in tasks_data:
                task = Task.objects.create(
                    est_worksheet=self.worksheet,
                    name=f'{name} #{i}',
                    units=units,
                    rate=Decimal(rate),
                    est_qty=Decimal(qty)
                )
                
                TaskMapping.objects.create(
                    task=task,
                    step_type=step_type,
                    mapping_strategy='bundle_to_product',
                    product_identifier=product_id,
                    product_type='chair',
                    product_instance=i,
                    task_type_id=name.lower().replace(' ', '_')
                )
        
        # Generate estimate
        estimate = self.service.generate_estimate_from_worksheet(self.worksheet)
        
        # Verify single combined line item
        line_items = estimate.estimatelineitem_set.all()
        self.assertEqual(line_items.count(), 1)
        
        line_item = line_items.first()
        self.assertEqual(line_item.description, 'Dining Chair Set')
        self.assertEqual(line_item.qty, Decimal('4.00'))  # 4 chairs
        self.assertEqual(line_item.units, 'each')
        
        # Each chair: (2*75) + (1*100) + (1.5*50) = 150 + 100 + 75 = 325
        # Total for 4 chairs: 325 * 4 = 1300
        expected_price = Decimal('1300.00')
        self.assertEqual(line_item.price_currency, expected_price)
    
    def test_product_bundle_multiple_instances_separate(self):
        """Test bundling multiple instances as separate line items"""
        # Create bundling rule that keeps instances separate
        rule = ProductBundlingRule.objects.create(
            rule_name='Custom Item Bundling',
            product_type='custom_item',
            line_item_template='Custom {product_type}',
            combine_instances=False,  # Keep separate
            pricing_method='sum_components'
        )
        
        # Create 2 custom items
        for i in range(1, 3):
            product_id = f'custom_item_{i:03d}'
            
            task = Task.objects.create(
                est_worksheet=self.worksheet,
                name=f'Custom Item #{i}',
                units='hours',
                rate=Decimal('200.00'),
                est_qty=Decimal('5.00')
            )
            
            TaskMapping.objects.create(
                task=task,
                step_type='labor',
                mapping_strategy='bundle_to_product',
                product_identifier=product_id,
                product_type='custom_item',
                product_instance=i,
                task_type_id='custom'
            )
        
        # Generate estimate
        estimate = self.service.generate_estimate_from_worksheet(self.worksheet)
        
        # Verify separate line items
        line_items = estimate.estimatelineitem_set.all().order_by('line_number')
        self.assertEqual(line_items.count(), 2)
        
        for i, line_item in enumerate(line_items, 1):
            self.assertEqual(line_item.description, 'Custom Custom_Item')
            self.assertEqual(line_item.qty, Decimal('1.00'))
            self.assertEqual(line_item.price_currency, Decimal('1000.00'))  # 5 * 200
    
    def test_service_bundle(self):
        """Test bundling tasks into service line items"""
        # Create tasks for installation service
        tasks_data = [
            ('Site Preparation', 'site_prep', 'hours', '100.00', '2.00'),
            ('Installation', 'installation', 'hours', '125.00', '4.00'),
            ('Testing', 'installation', 'hours', '100.00', '1.00'),
            ('Cleanup', 'site_prep', 'hours', '75.00', '1.50'),
        ]
        
        for name, service_type, units, rate, qty in tasks_data:
            task = Task.objects.create(
                est_worksheet=self.worksheet,
                name=name,
                units=units,
                rate=Decimal(rate),
                est_qty=Decimal(qty)
            )
            
            TaskMapping.objects.create(
                task=task,
                step_type='labor',
                mapping_strategy='bundle_to_service',
                product_type=service_type,  # Used as service bundle key
                task_type_id=name.lower().replace(' ', '_')
            )
        
        # Generate estimate
        estimate = self.service.generate_estimate_from_worksheet(self.worksheet)
        
        # Verify service bundles were created
        line_items = estimate.estimatelineitem_set.all().order_by('line_number')
        self.assertEqual(line_items.count(), 2)
        
        # Check site_prep bundle
        site_prep_item = next(item for item in line_items if 'Site Prep' in item.description)
        self.assertIn('Site Preparation', site_prep_item.description)
        self.assertIn('Cleanup', site_prep_item.description)
        self.assertEqual(site_prep_item.qty, Decimal('3.50'))  # 2 + 1.5 hours
        self.assertEqual(site_prep_item.price_currency, Decimal('312.50'))  # (2*100) + (1.5*75)
        
        # Check installation bundle
        install_item = next(item for item in line_items if 'Installation' in item.description)
        self.assertIn('Installation', install_item.description)
        self.assertIn('Testing', install_item.description)
        self.assertEqual(install_item.qty, Decimal('5.00'))  # 4 + 1 hours
        self.assertEqual(install_item.price_currency, Decimal('600.00'))  # (4*125) + (1*100)
    
    def test_exclude_mapping(self):
        """Test that tasks marked as exclude don't appear in the estimate"""
        # Create visible task
        visible_task = Task.objects.create(
            est_worksheet=self.worksheet,
            name='Customer Visible Task',
            units='hours',
            rate=Decimal('100.00'),
            est_qty=Decimal('5.00')
        )
        
        TaskMapping.objects.create(
            task=visible_task,
            step_type='labor',
            mapping_strategy='direct',
            task_type_id='visible'
        )
        
        # Create excluded tasks (internal/overhead)
        excluded_tasks = [
            'Internal Planning',
            'Team Coordination',
            'Administrative Overhead'
        ]
        
        for name in excluded_tasks:
            task = Task.objects.create(
                est_worksheet=self.worksheet,
                name=name,
                units='hours',
                rate=Decimal('50.00'),
                est_qty=Decimal('2.00')
            )
            
            TaskMapping.objects.create(
                task=task,
                step_type='overhead',
                mapping_strategy='exclude',
                task_type_id=name.lower().replace(' ', '_')
            )
        
        # Generate estimate
        estimate = self.service.generate_estimate_from_worksheet(self.worksheet)
        
        # Verify only visible task appears
        line_items = estimate.estimatelineitem_set.all()
        self.assertEqual(line_items.count(), 1)
        
        line_item = line_items.first()
        self.assertEqual(line_item.description, 'Customer Visible Task')
        self.assertEqual(line_item.price_currency, Decimal('500.00'))
    
    def test_mixed_mapping_strategies(self):
        """Test worksheet with all mapping strategies combined"""
        # Direct mapping task
        direct_task = Task.objects.create(
            est_worksheet=self.worksheet,
            name='Consultation',
            units='hours',
            rate=Decimal('150.00'),
            est_qty=Decimal('2.00')
        )
        TaskMapping.objects.create(
            task=direct_task,
            step_type='labor',
            mapping_strategy='direct',
            task_type_id='consult'
        )
        
        # Product bundle - Table
        table_tasks = [
            ('Table Design', 'labor', '150.00', '4.00'),
            ('Table Materials', 'material', '50.00', '20.00'),
            ('Table Assembly', 'labor', '100.00', '6.00'),
        ]
        
        for name, step_type, rate, qty in table_tasks:
            task = Task.objects.create(
                est_worksheet=self.worksheet,
                name=name,
                units='hours' if step_type == 'labor' else 'each',
                rate=Decimal(rate),
                est_qty=Decimal(qty)
            )
            TaskMapping.objects.create(
                task=task,
                step_type=step_type,
                mapping_strategy='bundle_to_product',
                product_identifier='table_001',
                product_type='table',
                task_type_id=name.lower().replace(' ', '_')
            )
        
        # Service bundle
        service_tasks = [
            ('Delivery', '75.00', '2.00'),
            ('Setup', '100.00', '1.50'),
        ]
        
        for name, rate, qty in service_tasks:
            task = Task.objects.create(
                est_worksheet=self.worksheet,
                name=name,
                units='hours',
                rate=Decimal(rate),
                est_qty=Decimal(qty)
            )
            TaskMapping.objects.create(
                task=task,
                step_type='labor',
                mapping_strategy='bundle_to_service',
                product_type='delivery_service',
                task_type_id=name.lower()
            )
        
        # Excluded task
        excluded_task = Task.objects.create(
            est_worksheet=self.worksheet,
            name='Internal QA',
            units='hours',
            rate=Decimal('80.00'),
            est_qty=Decimal('3.00')
        )
        TaskMapping.objects.create(
            task=excluded_task,
            step_type='overhead',
            mapping_strategy='exclude',
            task_type_id='qa'
        )
        
        # Create bundling rule for table
        ProductBundlingRule.objects.create(
            rule_name='Table Rule',
            product_type='table',
            line_item_template='Custom Table',
            pricing_method='sum_components'
        )
        
        # Generate estimate
        estimate = self.service.generate_estimate_from_worksheet(self.worksheet)
        
        # Verify correct number of line items (direct + product + service, no excluded)
        line_items = estimate.estimatelineitem_set.all().order_by('line_number')
        self.assertEqual(line_items.count(), 3)
        
        # Verify each type
        descriptions = [item.description for item in line_items]
        
        # Should have consultation (direct)
        self.assertTrue(any('Consultation' in d for d in descriptions))
        
        # Should have table (product bundle)
        self.assertTrue(any('Custom Table' in d for d in descriptions))
        
        # Should have delivery service (service bundle)
        self.assertTrue(any('Delivery' in d for d in descriptions))
        
        # Should NOT have internal QA
        self.assertFalse(any('Internal QA' in d for d in descriptions))
    
    def test_tasks_without_mapping_default_to_direct(self):
        """Test that tasks without TaskMapping are treated as direct mapping"""
        # Create task without mapping
        task = Task.objects.create(
            est_worksheet=self.worksheet,
            name='Unmapped Task',
            units='each',
            rate=Decimal('250.00'),
            est_qty=Decimal('3.00')
        )
        
        # Generate estimate
        estimate = self.service.generate_estimate_from_worksheet(self.worksheet)
        
        # Verify task appears as direct line item
        line_items = estimate.estimatelineitem_set.all()
        self.assertEqual(line_items.count(), 1)
        
        line_item = line_items.first()
        self.assertEqual(line_item.description, 'Unmapped Task')
        self.assertEqual(line_item.qty, Decimal('3.00'))
        self.assertEqual(line_item.price_currency, Decimal('750.00'))
    
    def test_bundling_rule_with_template_base_pricing(self):
        """Test using template base price instead of summing components"""
        # Create work order template with base price
        template = WorkOrderTemplate.objects.create(
            template_name='Standard Package',
            template_type='product',
            product_type='package',
            base_price=Decimal('2500.00')  # Fixed price regardless of components
        )
        
        # Create tasks that would sum to different amount
        tasks_data = [
            ('Task A', '100.00', '5.00'),  # 500
            ('Task B', '200.00', '3.00'),  # 600
            ('Task C', '150.00', '4.00'),  # 600
        ]  # Total would be 1700, but should use template price of 2500
        
        for name, rate, qty in tasks_data:
            task = Task.objects.create(
                est_worksheet=self.worksheet,
                name=name,
                units='hours',
                rate=Decimal(rate),
                est_qty=Decimal(qty)
            )
            TaskMapping.objects.create(
                task=task,
                step_type='labor',
                mapping_strategy='bundle_to_product',
                product_identifier='package_001',
                product_type='package',
                task_type_id=name.lower().replace(' ', '_')
            )
        
        # Create rule using template base pricing
        rule = ProductBundlingRule.objects.create(
            rule_name='Package Rule',
            product_type='package',
            work_order_template=template,
            line_item_template='Standard Service Package',
            pricing_method='template_base'  # Use template price
        )
        
        # Generate estimate
        estimate = self.service.generate_estimate_from_worksheet(self.worksheet)
        
        # Verify template price is used
        line_items = estimate.estimatelineitem_set.all()
        self.assertEqual(line_items.count(), 1)
        
        line_item = line_items.first()
        self.assertEqual(line_item.description, 'Standard Service Package')
        self.assertEqual(line_item.price_currency, Decimal('2500.00'))  # Template price, not sum
    
    def test_bundling_rule_material_labor_filtering(self):
        """Test bundling rules that include/exclude certain step types"""
        # Create tasks with different step types
        tasks_data = [
            ('Labor Task', 'labor', '100.00', '5.00'),      # 500
            ('Material Task', 'material', '50.00', '10.00'), # 500
            ('Overhead Task', 'overhead', '75.00', '4.00'),  # 300
        ]
        
        for name, step_type, rate, qty in tasks_data:
            task = Task.objects.create(
                est_worksheet=self.worksheet,
                name=name,
                units='hours' if step_type == 'labor' else 'each',
                rate=Decimal(rate),
                est_qty=Decimal(qty)
            )
            TaskMapping.objects.create(
                task=task,
                step_type=step_type,
                mapping_strategy='bundle_to_product',
                product_identifier='filtered_product',
                product_type='filtered',
                task_type_id=name.lower().replace(' ', '_')
            )
        
        # Create rule that excludes overhead
        rule = ProductBundlingRule.objects.create(
            rule_name='Filtered Rule',
            product_type='filtered',
            line_item_template='Filtered Product',
            pricing_method='sum_components',
            include_labor=True,
            include_materials=True,
            include_overhead=False  # Exclude overhead
        )
        
        # Generate estimate
        estimate = self.service.generate_estimate_from_worksheet(self.worksheet)
        
        # Verify only labor and materials are included in price
        line_items = estimate.estimatelineitem_set.all()
        self.assertEqual(line_items.count(), 1)
        
        line_item = line_items.first()
        # Should be 500 (labor) + 500 (material), not including 300 (overhead)
        self.assertEqual(line_item.price_currency, Decimal('1000.00'))
    
    def test_worksheet_with_no_tasks_raises_error(self):
        """Test that worksheet with no tasks raises appropriate error"""
        empty_worksheet = EstWorksheet.objects.create(
            job=self.job,
            status='draft'
        )
        
        with self.assertRaises(ValueError) as context:
            self.service.generate_estimate_from_worksheet(empty_worksheet)
        
        self.assertIn('has no tasks to convert', str(context.exception))
    
    def test_estimate_number_generation(self):
        """Test that estimate numbers are generated correctly"""
        # Create first estimate
        task1 = Task.objects.create(
            est_worksheet=self.worksheet,
            name='Task 1',
            rate=Decimal('100.00'),
            est_qty=Decimal('1.00')
        )
        
        estimate1 = self.service.generate_estimate_from_worksheet(self.worksheet)
        self.assertEqual(estimate1.estimate_number, '1000')
        
        # Create second worksheet and estimate
        worksheet2 = EstWorksheet.objects.create(job=self.job, status='draft')
        task2 = Task.objects.create(
            est_worksheet=worksheet2,
            name='Task 2',
            rate=Decimal('100.00'),
            est_qty=Decimal('1.00')
        )
        
        service2 = EstimateGenerationService()
        estimate2 = service2.generate_estimate_from_worksheet(worksheet2)
        self.assertEqual(estimate2.estimate_number, '1001')
    
    def test_worksheet_linked_to_estimate_after_generation(self):
        """Test that worksheet is linked to estimate after generation"""
        task = Task.objects.create(
            est_worksheet=self.worksheet,
            name='Test Task',
            rate=Decimal('100.00'),
            est_qty=Decimal('1.00')
        )
        
        # Worksheet should not have estimate initially
        self.assertIsNone(self.worksheet.estimate)
        
        # Generate estimate
        estimate = self.service.generate_estimate_from_worksheet(self.worksheet)
        
        # Reload worksheet from database
        self.worksheet.refresh_from_db()
        
        # Worksheet should now be linked to estimate
        self.assertEqual(self.worksheet.estimate, estimate)
    
    def test_multiple_product_bundles_different_types(self):
        """Test handling multiple different product types in same worksheet"""
        # Create table tasks
        table_tasks = [
            ('Table Design', 'labor', '150.00', '4.00'),
            ('Table Wood', 'material', '50.00', '20.00'),
        ]
        
        for name, step_type, rate, qty in table_tasks:
            task = Task.objects.create(
                est_worksheet=self.worksheet,
                name=name,
                units='hours' if step_type == 'labor' else 'each',
                rate=Decimal(rate),
                est_qty=Decimal(qty)
            )
            TaskMapping.objects.create(
                task=task,
                step_type=step_type,
                mapping_strategy='bundle_to_product',
                product_identifier='table_001',
                product_type='table',
                task_type_id=name.lower().replace(' ', '_')
            )
        
        # Create chair tasks (2 chairs)
        for i in range(1, 3):
            chair_tasks = [
                (f'Chair #{i} Frame', 'labor', '75.00', '2.00'),
                (f'Chair #{i} Materials', 'material', '100.00', '1.00'),
            ]
            
            for name, step_type, rate, qty in chair_tasks:
                task = Task.objects.create(
                    est_worksheet=self.worksheet,
                    name=name,
                    units='hours' if step_type == 'labor' else 'each',
                    rate=Decimal(rate),
                    est_qty=Decimal(qty)
                )
                TaskMapping.objects.create(
                    task=task,
                    step_type=step_type,
                    mapping_strategy='bundle_to_product',
                    product_identifier=f'chair_{i:03d}',
                    product_type='chair',
                    product_instance=i,
                    task_type_id='chair'
                )
        
        # Create rules for both product types
        ProductBundlingRule.objects.create(
            rule_name='Table Rule',
            product_type='table',
            line_item_template='Custom Table',
            combine_instances=False,
            pricing_method='sum_components'
        )
        
        ProductBundlingRule.objects.create(
            rule_name='Chair Rule',
            product_type='chair',
            line_item_template='Custom Chairs',
            combine_instances=True,  # Combine chairs
            pricing_method='sum_components'
        )
        
        # Generate estimate
        estimate = self.service.generate_estimate_from_worksheet(self.worksheet)
        
        # Should have 2 line items: 1 table, 1 combined chairs
        line_items = estimate.estimatelineitem_set.all()
        self.assertEqual(line_items.count(), 2)
        
        # Verify table line item
        table_item = next(item for item in line_items if 'Table' in item.description)
        self.assertEqual(table_item.qty, Decimal('1.00'))
        self.assertEqual(table_item.price_currency, Decimal('1600.00'))  # 600 + 1000
        
        # Verify chairs line item (combined)
        chair_item = next(item for item in line_items if 'Chair' in item.description)
        self.assertEqual(chair_item.qty, Decimal('2.00'))  # 2 chairs
        self.assertEqual(chair_item.price_currency, Decimal('500.00'))  # 2 * (150 + 100)